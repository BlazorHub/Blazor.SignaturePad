/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var signature_pad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! signature_pad */ \"./node_modules/signature_pad/dist/signature_pad.m.js\");\n// Copyright (c) 2020 Allan Mobley. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nwindow.Blazor.SignaturePad = {\n  init: function init(instance) {\n    window.Blazor.SignaturePad.instance = instance;\n    window.Blazor.SignaturePad.self = new signature_pad__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.getElementById('signature-pad--canvas'));\n    window.Blazor.SignaturePad.self.onEnd = OnEndCallBack;\n    initEvents();\n    resizeCanvas();\n  },\n  toDataURL: function toDataURL(type) {\n    var dataURL = null;\n\n    switch (type) {\n      case 'png':\n        dataURL = _toDataURL('image/png');\n        break;\n\n      case 'svg':\n        dataURL = _toDataURL('image/svg+xml');\n        break;\n\n      case 'jpg':\n        dataURL = toDataURL_JPEG();\n        break;\n\n      default:\n        break;\n    }\n\n    return dataURL;\n  }\n};\n\nvar OnEndCallBack = function OnEndCallBack() {\n  window.Blazor.SignaturePad.instance.invokeMethodAsync('OnEnd');\n};\n\nvar initEvents = function initEvents() {\n  initResizeEvent();\n  initPenColorChangeEvent();\n  initClearClickEvent();\n  initUndoClickEvent();\n  initSaveClickEvent();\n};\n\nvar _toDataURL = function _toDataURL(type) {\n  return window.Blazor.SignaturePad.self.isEmpty() ? null : window.Blazor.SignaturePad.self.toDataURL(type);\n}; // JPEG's are a special case.\n\n\nvar toDataURL_JPEG = function toDataURL_JPEG() {\n  if (window.Blazor.SignaturePad.self.isEmpty()) {\n    return null;\n  } else {\n    // Save current signature.\n    var data = window.Blazor.SignaturePad.self.toData(); // It's necessary to use an opaque background color when saving image as JPEG.\n\n    window.Blazor.SignaturePad.self.backgroundColor = 'rgb(255, 255, 255)'; // Write signature back against opaque background.\n\n    window.Blazor.SignaturePad.self.fromData(data); // Save data url.\n\n    var dataURL = _toDataURL('image/jpeg'); // Reset background to default.\n\n\n    window.Blazor.SignaturePad.self.backgroundColor = 'rgba(0,0,0,0)'; // Write signature back against default background.\n\n    window.Blazor.SignaturePad.self.fromData(data); // Return signature against opaque background.\n\n    return dataURL;\n  }\n};\n\nvar initResizeEvent = function initResizeEvent() {\n  window.onresize = resizeCanvas;\n};\n\nvar initPenColorChangeEvent = function initPenColorChangeEvent() {\n  var penColor = document.getElementById('signature-pad--pen-color');\n\n  if (penColor) {\n    penColor.addEventListener('change', function (event) {\n      window.Blazor.SignaturePad.self.penColor = penColor.value;\n    });\n  }\n};\n\nvar initClearClickEvent = function initClearClickEvent() {\n  var clearButton = document.getElementById('signature-pad--clear');\n\n  if (clearButton) {\n    clearButton.addEventListener('click', function (event) {\n      window.Blazor.SignaturePad.self.clear();\n      OnEndCallBack();\n    });\n  }\n};\n\nvar initUndoClickEvent = function initUndoClickEvent() {\n  var undoButton = document.getElementById('signature-pad--undo');\n\n  if (undoButton) {\n    undoButton.addEventListener('click', function (event) {\n      var data = window.Blazor.SignaturePad.self.toData();\n\n      if (data) {\n        data.pop(); // remove the last dot or line\n\n        window.Blazor.SignaturePad.self.fromData(data);\n        OnEndCallBack();\n      }\n    });\n  }\n};\n\nvar initSaveClickEvent = function initSaveClickEvent() {\n  var element = document.querySelector('.signature-pad--save');\n\n  if (element) {\n    element.addEventListener('click', function (event) {\n      switch (this.id) {\n        case 'signature-pad--save-png':\n          var dataURL = _toDataURL();\n\n          if (dataURL) {\n            download(dataURL, 'signature.png');\n          }\n\n          break;\n\n        case 'signature-pad--save-jpg':\n          var dataURL = toDataURL_JPEG(); // JPEG's are a special case.\n\n          if (dataURL) {\n            download(dataURL, 'signature.jpg');\n          }\n\n          break;\n\n        case 'signature-pad--save-svg':\n          var dataURL = _toDataURL('image/svg+xml');\n\n          if (dataURL) {\n            download(dataURL, 'signature.svg');\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    });\n  }\n}; // Adjust canvas coordinate space taking into account pixel ratio, to make it look crisp on mobile devices.\n// This also causes canvas to be cleared.\n\n\nfunction resizeCanvas() {\n  var canvas = document.getElementById('signature-pad--canvas');\n\n  if (canvas) {\n    // Store signature in memory before resizing so as not to lose it.\n    var data = window.Blazor.SignaturePad.self.toData(); // When zoomed out to less than 100%, for some very strange reason,\n    // some browsers report devicePixelRatio as less than 1\n    // and only part of the canvas is cleared then.\n\n    var ratio = Math.max(window.devicePixelRatio || 1, 1); // This part causes the canvas to be cleared\n\n    canvas.width = canvas.offsetWidth * ratio;\n    canvas.height = canvas.offsetHeight * ratio;\n    canvas.getContext('2d').scale(ratio, ratio); // This library does not listen for canvas changes, so after the canvas is automatically\n    // cleared by the browser, SignaturePad#isEmpty might still return false, even though the\n    // canvas looks empty, because the internal data of this library wasn't cleared. To make sure\n    // that the state of this library is consistent with visual state of the canvas, you\n    // have to clear it manually.\n\n    window.Blazor.SignaturePad.self.clear(); // Write signature back.\n\n    window.Blazor.SignaturePad.self.fromData(data);\n  }\n}\n\nfunction download(dataURL, filename) {\n  var a = document.createElement('a');\n  a.style = 'display: none';\n  a.href = dataURL;\n  a.download = filename;\n  a.target = '_blank';\n  document.body.appendChild(a);\n  a.click();\n}\n\n//# sourceURL=webpack:///./app.js?");

/***/ }),

/***/ "./app.scss":
/*!******************!*\
  !*** ./app.scss ***!
  \******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"bundle.css\");\n\n//# sourceURL=webpack:///./app.scss?");

/***/ }),

/***/ "./node_modules/signature_pad/dist/signature_pad.m.js":
/*!************************************************************!*\
  !*** ./node_modules/signature_pad/dist/signature_pad.m.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n * Signature Pad v3.0.0-beta.3 | https://github.com/szimek/signature_pad\n * (c) 2018 Szymon Nowak | Released under the MIT license\n */\nvar Point = /*#__PURE__*/function () {\n  function Point(x, y, time) {\n    _classCallCheck(this, Point);\n\n    this.x = x;\n    this.y = y;\n    this.time = time || Date.now();\n  }\n\n  _createClass(Point, [{\n    key: \"distanceTo\",\n    value: function distanceTo(start) {\n      return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y && this.time === other.time;\n    }\n  }, {\n    key: \"velocityFrom\",\n    value: function velocityFrom(start) {\n      return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;\n    }\n  }]);\n\n  return Point;\n}();\n\nvar Bezier = /*#__PURE__*/function () {\n  function Bezier(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n    _classCallCheck(this, Bezier);\n\n    this.startPoint = startPoint;\n    this.control2 = control2;\n    this.control1 = control1;\n    this.endPoint = endPoint;\n    this.startWidth = startWidth;\n    this.endWidth = endWidth;\n  }\n\n  _createClass(Bezier, [{\n    key: \"length\",\n    value: function length() {\n      var steps = 10;\n      var length = 0;\n      var px;\n      var py;\n\n      for (var i = 0; i <= steps; i += 1) {\n        var t = i / steps;\n        var cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n        var cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n\n        if (i > 0) {\n          var xdiff = cx - px;\n          var ydiff = cy - py;\n          length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n        }\n\n        px = cx;\n        py = cy;\n      }\n\n      return length;\n    }\n  }, {\n    key: \"point\",\n    value: function point(t, start, c1, c2, end) {\n      return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;\n    }\n  }], [{\n    key: \"fromPoints\",\n    value: function fromPoints(points, widths) {\n      var c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n      var c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n      return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n  }, {\n    key: \"calculateControlPoints\",\n    value: function calculateControlPoints(s1, s2, s3) {\n      var dx1 = s1.x - s2.x;\n      var dy1 = s1.y - s2.y;\n      var dx2 = s2.x - s3.x;\n      var dy2 = s2.y - s3.y;\n      var m1 = {\n        x: (s1.x + s2.x) / 2.0,\n        y: (s1.y + s2.y) / 2.0\n      };\n      var m2 = {\n        x: (s2.x + s3.x) / 2.0,\n        y: (s2.y + s3.y) / 2.0\n      };\n      var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n      var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n      var dxm = m1.x - m2.x;\n      var dym = m1.y - m2.y;\n      var k = l2 / (l1 + l2);\n      var cm = {\n        x: m2.x + dxm * k,\n        y: m2.y + dym * k\n      };\n      var tx = s2.x - cm.x;\n      var ty = s2.y - cm.y;\n      return {\n        c1: new Point(m1.x + tx, m1.y + ty),\n        c2: new Point(m2.x + tx, m2.y + ty)\n      };\n    }\n  }]);\n\n  return Bezier;\n}();\n\nfunction throttle(fn) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;\n  var previous = 0;\n  var timeout = null;\n  var result;\n  var storedContext;\n  var storedArgs;\n\n  var later = function later() {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n\n  return function () {\n    var now = Date.now();\n    var remaining = wait - (now - previous);\n    storedContext = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    storedArgs = args;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n\nvar SignaturePad = /*#__PURE__*/function () {\n  function SignaturePad(canvas) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, SignaturePad);\n\n    this.canvas = canvas;\n    this.options = options;\n\n    this._handleMouseDown = function (event) {\n      if (event.which === 1) {\n        _this._mouseButtonDown = true;\n\n        _this._strokeBegin(event);\n      }\n    };\n\n    this._handleMouseMove = function (event) {\n      if (_this._mouseButtonDown) {\n        _this._strokeMoveUpdate(event);\n      }\n    };\n\n    this._handleMouseUp = function (event) {\n      if (event.which === 1 && _this._mouseButtonDown) {\n        _this._mouseButtonDown = false;\n\n        _this._strokeEnd(event);\n      }\n    };\n\n    this._handleTouchStart = function (event) {\n      event.preventDefault();\n\n      if (event.targetTouches.length === 1) {\n        var touch = event.changedTouches[0];\n\n        _this._strokeBegin(touch);\n      }\n    };\n\n    this._handleTouchMove = function (event) {\n      event.preventDefault();\n      var touch = event.targetTouches[0];\n\n      _this._strokeMoveUpdate(touch);\n    };\n\n    this._handleTouchEnd = function (event) {\n      var wasCanvasTouched = event.target === _this.canvas;\n\n      if (wasCanvasTouched) {\n        event.preventDefault();\n        var touch = event.changedTouches[0];\n\n        _this._strokeEnd(touch);\n      }\n    };\n\n    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    this.minWidth = options.minWidth || 0.5;\n    this.maxWidth = options.maxWidth || 2.5;\n    this.throttle = 'throttle' in options ? options.throttle : 16;\n    this.minDistance = 'minDistance' in options ? options.minDistance : 5;\n\n    if (this.throttle) {\n      this._strokeMoveUpdate = throttle(SignaturePad.prototype._strokeUpdate, this.throttle);\n    } else {\n      this._strokeMoveUpdate = SignaturePad.prototype._strokeUpdate;\n    }\n\n    this.dotSize = options.dotSize || function () {\n      return (this.minWidth + this.maxWidth) / 2;\n    };\n\n    this.penColor = options.penColor || 'black';\n    this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n    this.onBegin = options.onBegin;\n    this.onEnd = options.onEnd;\n    this._ctx = canvas.getContext('2d');\n    this.clear();\n    this.on();\n  }\n\n  _createClass(SignaturePad, [{\n    key: \"clear\",\n    value: function clear() {\n      var ctx = this._ctx;\n      var canvas = this.canvas;\n      ctx.fillStyle = this.backgroundColor;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      this._data = [];\n\n      this._reset();\n\n      this._isEmpty = true;\n    }\n  }, {\n    key: \"fromDataURL\",\n    value: function fromDataURL(dataUrl) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      var image = new Image();\n      var ratio = options.ratio || window.devicePixelRatio || 1;\n      var width = options.width || this.canvas.width / ratio;\n      var height = options.height || this.canvas.height / ratio;\n\n      this._reset();\n\n      image.onload = function () {\n        _this2._ctx.drawImage(image, 0, 0, width, height);\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      image.onerror = function (error) {\n        if (callback) {\n          callback(error);\n        }\n      };\n\n      image.src = dataUrl;\n      this._isEmpty = false;\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function toDataURL() {\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';\n      var encoderOptions = arguments.length > 1 ? arguments[1] : undefined;\n\n      switch (type) {\n        case 'image/svg+xml':\n          return this._toSVG();\n\n        default:\n          return this.canvas.toDataURL(type, encoderOptions);\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on() {\n      this.canvas.style.touchAction = 'none';\n      this.canvas.style.msTouchAction = 'none';\n\n      if (window.PointerEvent) {\n        this._handlePointerEvents();\n      } else {\n        this._handleMouseEvents();\n\n        if ('ontouchstart' in window) {\n          this._handleTouchEvents();\n        }\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off() {\n      this.canvas.style.touchAction = 'auto';\n      this.canvas.style.msTouchAction = 'auto';\n      this.canvas.removeEventListener('pointerdown', this._handleMouseDown);\n      this.canvas.removeEventListener('pointermove', this._handleMouseMove);\n      document.removeEventListener('pointerup', this._handleMouseUp);\n      this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n      this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n      document.removeEventListener('mouseup', this._handleMouseUp);\n      this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n      this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n      this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._isEmpty;\n    }\n  }, {\n    key: \"fromData\",\n    value: function fromData(pointGroups) {\n      var _this3 = this;\n\n      this.clear();\n\n      this._fromData(pointGroups, function (_ref) {\n        var color = _ref.color,\n            curve = _ref.curve;\n        return _this3._drawCurve({\n          color: color,\n          curve: curve\n        });\n      }, function (_ref2) {\n        var color = _ref2.color,\n            point = _ref2.point;\n        return _this3._drawDot({\n          color: color,\n          point: point\n        });\n      });\n\n      this._data = pointGroups;\n    }\n  }, {\n    key: \"toData\",\n    value: function toData() {\n      return this._data;\n    }\n  }, {\n    key: \"_strokeBegin\",\n    value: function _strokeBegin(event) {\n      var newPointGroup = {\n        color: this.penColor,\n        points: []\n      };\n\n      this._data.push(newPointGroup);\n\n      this._reset();\n\n      this._strokeUpdate(event);\n\n      if (typeof this.onBegin === 'function') {\n        this.onBegin(event);\n      }\n    }\n  }, {\n    key: \"_strokeUpdate\",\n    value: function _strokeUpdate(event) {\n      var x = event.clientX;\n      var y = event.clientY;\n\n      var point = this._createPoint(x, y);\n\n      var lastPointGroup = this._data[this._data.length - 1];\n      var lastPoints = lastPointGroup.points;\n      var lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n      var isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;\n      var color = lastPointGroup.color;\n\n      if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n        var curve = this._addPoint(point);\n\n        if (!lastPoint) {\n          this._drawDot({\n            color: color,\n            point: point\n          });\n        } else if (curve) {\n          this._drawCurve({\n            color: color,\n            curve: curve\n          });\n        }\n\n        lastPoints.push({\n          time: point.time,\n          x: point.x,\n          y: point.y\n        });\n      }\n    }\n  }, {\n    key: \"_strokeEnd\",\n    value: function _strokeEnd(event) {\n      this._strokeUpdate(event);\n\n      if (typeof this.onEnd === 'function') {\n        this.onEnd(event);\n      }\n    }\n  }, {\n    key: \"_handlePointerEvents\",\n    value: function _handlePointerEvents() {\n      this._mouseButtonDown = false;\n      this.canvas.addEventListener('pointerdown', this._handleMouseDown);\n      this.canvas.addEventListener('pointermove', this._handleMouseMove);\n      document.addEventListener('pointerup', this._handleMouseUp);\n    }\n  }, {\n    key: \"_handleMouseEvents\",\n    value: function _handleMouseEvents() {\n      this._mouseButtonDown = false;\n      this.canvas.addEventListener('mousedown', this._handleMouseDown);\n      this.canvas.addEventListener('mousemove', this._handleMouseMove);\n      document.addEventListener('mouseup', this._handleMouseUp);\n    }\n  }, {\n    key: \"_handleTouchEvents\",\n    value: function _handleTouchEvents() {\n      this.canvas.addEventListener('touchstart', this._handleTouchStart);\n      this.canvas.addEventListener('touchmove', this._handleTouchMove);\n      this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._lastPoints = [];\n      this._lastVelocity = 0;\n      this._lastWidth = (this.minWidth + this.maxWidth) / 2;\n      this._ctx.fillStyle = this.penColor;\n    }\n  }, {\n    key: \"_createPoint\",\n    value: function _createPoint(x, y) {\n      var rect = this.canvas.getBoundingClientRect();\n      return new Point(x - rect.left, y - rect.top, new Date().getTime());\n    }\n  }, {\n    key: \"_addPoint\",\n    value: function _addPoint(point) {\n      var _lastPoints = this._lastPoints;\n\n      _lastPoints.push(point);\n\n      if (_lastPoints.length > 2) {\n        if (_lastPoints.length === 3) {\n          _lastPoints.unshift(_lastPoints[0]);\n        }\n\n        var widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);\n\n        var curve = Bezier.fromPoints(_lastPoints, widths);\n\n        _lastPoints.shift();\n\n        return curve;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_calculateCurveWidths\",\n    value: function _calculateCurveWidths(startPoint, endPoint) {\n      var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;\n\n      var newWidth = this._strokeWidth(velocity);\n\n      var widths = {\n        end: newWidth,\n        start: this._lastWidth\n      };\n      this._lastVelocity = velocity;\n      this._lastWidth = newWidth;\n      return widths;\n    }\n  }, {\n    key: \"_strokeWidth\",\n    value: function _strokeWidth(velocity) {\n      return Math.max(this.maxWidth / (velocity + 1), this.minWidth);\n    }\n  }, {\n    key: \"_drawCurveSegment\",\n    value: function _drawCurveSegment(x, y, width) {\n      var ctx = this._ctx;\n      ctx.moveTo(x, y);\n      ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n      this._isEmpty = false;\n    }\n  }, {\n    key: \"_drawCurve\",\n    value: function _drawCurve(_ref3) {\n      var color = _ref3.color,\n          curve = _ref3.curve;\n      var ctx = this._ctx;\n      var widthDelta = curve.endWidth - curve.startWidth;\n      var drawSteps = Math.floor(curve.length()) * 2;\n      ctx.beginPath();\n      ctx.fillStyle = color;\n\n      for (var i = 0; i < drawSteps; i += 1) {\n        var t = i / drawSteps;\n        var tt = t * t;\n        var ttt = tt * t;\n        var u = 1 - t;\n        var uu = u * u;\n        var uuu = uu * u;\n        var x = uuu * curve.startPoint.x;\n        x += 3 * uu * t * curve.control1.x;\n        x += 3 * u * tt * curve.control2.x;\n        x += ttt * curve.endPoint.x;\n        var y = uuu * curve.startPoint.y;\n        y += 3 * uu * t * curve.control1.y;\n        y += 3 * u * tt * curve.control2.y;\n        y += ttt * curve.endPoint.y;\n        var width = curve.startWidth + ttt * widthDelta;\n\n        this._drawCurveSegment(x, y, width);\n      }\n\n      ctx.closePath();\n      ctx.fill();\n    }\n  }, {\n    key: \"_drawDot\",\n    value: function _drawDot(_ref4) {\n      var color = _ref4.color,\n          point = _ref4.point;\n      var ctx = this._ctx;\n      var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n      ctx.beginPath();\n\n      this._drawCurveSegment(point.x, point.y, width);\n\n      ctx.closePath();\n      ctx.fillStyle = color;\n      ctx.fill();\n    }\n  }, {\n    key: \"_fromData\",\n    value: function _fromData(pointGroups, drawCurve, drawDot) {\n      var _iterator = _createForOfIteratorHelper(pointGroups),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var group = _step.value;\n          var color = group.color,\n              points = group.points;\n\n          if (points.length > 1) {\n            for (var j = 0; j < points.length; j += 1) {\n              var basicPoint = points[j];\n              var point = new Point(basicPoint.x, basicPoint.y, basicPoint.time);\n              this.penColor = color;\n\n              if (j === 0) {\n                this._reset();\n              }\n\n              var curve = this._addPoint(point);\n\n              if (curve) {\n                drawCurve({\n                  color: color,\n                  curve: curve\n                });\n              }\n            }\n          } else {\n            this._reset();\n\n            drawDot({\n              color: color,\n              point: points[0]\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_toSVG\",\n    value: function _toSVG() {\n      var _this4 = this;\n\n      var pointGroups = this._data;\n      var ratio = Math.max(window.devicePixelRatio || 1, 1);\n      var minX = 0;\n      var minY = 0;\n      var maxX = this.canvas.width / ratio;\n      var maxY = this.canvas.height / ratio;\n      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      svg.setAttribute('width', this.canvas.width.toString());\n      svg.setAttribute('height', this.canvas.height.toString());\n\n      this._fromData(pointGroups, function (_ref5) {\n        var color = _ref5.color,\n            curve = _ref5.curve;\n        var path = document.createElement('path');\n\n        if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\n          var attr = \"M \".concat(curve.startPoint.x.toFixed(3), \",\").concat(curve.startPoint.y.toFixed(3), \" \") + \"C \".concat(curve.control1.x.toFixed(3), \",\").concat(curve.control1.y.toFixed(3), \" \") + \"\".concat(curve.control2.x.toFixed(3), \",\").concat(curve.control2.y.toFixed(3), \" \") + \"\".concat(curve.endPoint.x.toFixed(3), \",\").concat(curve.endPoint.y.toFixed(3));\n          path.setAttribute('d', attr);\n          path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n          path.setAttribute('stroke', color);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke-linecap', 'round');\n          svg.appendChild(path);\n        }\n      }, function (_ref6) {\n        var color = _ref6.color,\n            point = _ref6.point;\n        var circle = document.createElement('circle');\n        var dotSize = typeof _this4.dotSize === 'function' ? _this4.dotSize() : _this4.dotSize;\n        circle.setAttribute('r', dotSize.toString());\n        circle.setAttribute('cx', point.x.toString());\n        circle.setAttribute('cy', point.y.toString());\n        circle.setAttribute('fill', color);\n        svg.appendChild(circle);\n      });\n\n      var prefix = 'data:image/svg+xml;base64,';\n      var header = '<svg' + ' xmlns=\"http://www.w3.org/2000/svg\"' + ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"' + \" viewBox=\\\"\".concat(minX, \" \").concat(minY, \" \").concat(maxX, \" \").concat(maxY, \"\\\"\") + \" width=\\\"\".concat(maxX, \"\\\"\") + \" height=\\\"\".concat(maxY, \"\\\"\") + '>';\n      var body = svg.innerHTML;\n\n      if (body === undefined) {\n        var dummy = document.createElement('dummy');\n        var nodes = svg.childNodes;\n        dummy.innerHTML = '';\n\n        for (var i = 0; i < nodes.length; i += 1) {\n          dummy.appendChild(nodes[i].cloneNode(true));\n        }\n\n        body = dummy.innerHTML;\n      }\n\n      var footer = '</svg>';\n      var data = header + body + footer;\n      return prefix + btoa(data);\n    }\n  }]);\n\n  return SignaturePad;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SignaturePad);\n\n//# sourceURL=webpack:///./node_modules/signature_pad/dist/signature_pad.m.js?");

/***/ }),

/***/ 0:
/*!*********************************!*\
  !*** multi ./app.scss ./app.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./app.scss */\"./app.scss\");\nmodule.exports = __webpack_require__(/*! ./app.js */\"./app.js\");\n\n\n//# sourceURL=webpack:///multi_./app.scss_./app.js?");

/***/ })

/******/ });